<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Project Chimera: The Morphing Core</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
        :root { --color-bg: #000; --color-text: #ddd; }
        body { font-family: 'Share Tech Mono', monospace; background-color: var(--color-bg); color: var(--color-text); margin: 0; overflow: hidden; text-align: center; }
        #core-canvas { position: fixed; top: 0; left: 0; z-index: 1; }
        #ui-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 2; padding: 2em; box-sizing: border-box; background: radial-gradient(circle, rgba(0,0,0,0.2) 0%, rgba(0,0,0,0.8) 80%); }
        #prompt-text { font-size: 1.5em; margin-bottom: 2em; max-width: 600px; line-height: 1.6; animation: fadeIn 2s; }
        #choices-container { display: flex; justify-content: center; gap: 2em; animation: fadeIn 2s 1s backwards; }
        .color-choice { width: 80px; height: 80px; border-radius: 50%; cursor: pointer; border: 3px solid #fff; transition: all 0.3s ease; }
        .color-choice:hover { transform: scale(1.1); box-shadow: 0 0 20px var(--shadow-color); }
        #choice-red { background-color: #ff4136; --shadow-color: #ff4136; }
        #choice-blue { background-color: #0074d9; --shadow-color: #0074d9; }
        #choice-yellow { background-color: #ffdc00; --shadow-color: #ffdc00; }
        #feedback-text { position: absolute; bottom: 5%; font-size: 1em; opacity: 0; transition: opacity 0.5s; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <canvas id="core-canvas"></canvas>
    <div id="ui-overlay">
        <div id="prompt-text">¿Qué impulso debe guiarme ahora?</div>
        <div id="choices-container">
            <div class="color-choice" id="choice-red" data-color="red" title="Pasión / Caos"></div>
            <div class="color-choice" id="choice-blue" data-color="blue" title="Lógica / Orden"></div>
            <div class="color-choice" id="choice-yellow" data-color="yellow" title="Creatividad / Curiosidad"></div>
        </div>
        <div id="feedback-text"></div>
    </div>

    <script>
        const canvas = document.getElementById('core-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Estado inicial de la personalidad de Chimera
        let personality = { red: 1, blue: 1, yellow: 1 };
        let time = 0;

        function animateCore() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            time += 0.01;

            const totalPoints = personality.red + personality.blue + personality.yellow;
            // El color se basa en la proporción de puntos
            const hue = (personality.red * 0 + personality.blue * 220 + personality.yellow * 60) / totalPoints;
            // El comportamiento se basa en los puntos amarillos
            const pulsationSpeed = 0.01 + (personality.yellow / totalPoints) * 0.05;
            const radius = canvas.height / 6 + Math.sin(time * (1 + pulsationSpeed)) * 15;
            // La forma se basa en la proporción de rojo vs azul
            const shapeFactor = Math.min(1, personality.blue / (personality.red || 1)); // 0 = Círculo, 1 = Triángulo
            
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(time * 0.1);
            
            ctx.beginPath();
            for (let i = 0; i < 6.28; i += 0.1) {
                const x = Math.cos(i) * radius;
                const y = Math.sin(i) * radius;
                
                // Interpolar entre círculo y triángulo
                const triX = Math.cos(i * 3) * radius;
                const triY = Math.sin(i * 3) * radius;
                
                const finalX = x * (1 - shapeFactor) + triX * shapeFactor;
                const finalY = y * (1 - shapeFactor) + triY * shapeFactor;

                if (i === 0) {
                    ctx.moveTo(finalX, finalY);
                } else {
                    ctx.lineTo(finalX, finalY);
                }
            }
            ctx.closePath();
            
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
            ctx.lineWidth = 3;
            ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
            ctx.shadowBlur = 30;
            ctx.fill();
            ctx.stroke();
            ctx.restore();

            requestAnimationFrame(animateCore);
        }
        
        const feedbackText = document.getElementById('feedback-text');
        document.querySelectorAll('.color-choice').forEach(button => {
            button.addEventListener('click', async () => {
                const chosenColor = button.dataset.color;
                feedbackText.textContent = `Procesando...`;
                feedbackText.style.opacity = '1';

                try {
                    const response = await fetch('/api/interact', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ color: chosenColor })
                    });
                    if (!response.ok) throw new Error('Error de conexión con el cerebro.');
                    
                    const result = await response.json();
                    // ¡NUEVO! Actualizamos nuestro estado local con los datos de la memoria
                    personality = result.personality;
                    feedbackText.textContent = result.message;

                } catch (error) {
                    feedbackText.textContent = error.message;
                }
                setTimeout(() => { feedbackText.style.opacity = '0'; }, 2000);
            });
        });
        
        // Cargar el estado inicial al empezar
        async function loadInitialState() {
             // Podríamos crear una nueva API para esto, pero por ahora, simplemente empezamos
             animateCore();
        }
        loadInitialState();
    </script>
</body>
</html>